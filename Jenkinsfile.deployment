pipeline {
    agent none  // No global agent - we select per VM

    options {
        buildDiscarder(logRotator(numToKeepStr: '10'))
        timestamps()
        disableConcurrentBuilds()
    }

    environment {
        COMPOSE_PROJECT_PREFIX = 'homelab'
        DEPLOYMENT_BASE = '/home/jenkins-agent/deployments'
    }

    parameters {
        choice(
            name: 'DEPLOY_MODE',
            choices: ['DEPLOY', 'START_MISSING', 'RESTART_ALL', 'CLEAN_DEPLOY'],
            description: '''Deployment mode:
â€¢ START_MISSING: Only start containers that are not running (no file changes)
â€¢ RESTART_ALL: Restart all containers (no file changes)
â€¢ DEPLOY: Copy configs from Git and restart services (keeps persistence/)
â€¢ CLEAN_DEPLOY: Delete everything including persistence/ and redeploy from scratch'''
        )
        string(
            name: 'DEPLOY_ONLY_VM',
            defaultValue: '',
            description: 'Deploy only to specific VM (IP address, e.g. "192.168.2.32"). Empty = all VMs'
        )
        string(
            name: 'DEPLOY_ONLY_SERVICE',
            defaultValue: '',
            description: 'Deploy only specific services (comma-separated, e.g. "traefik,portainer"). Empty = all'
        )
        booleanParam(
            name: 'PRUNE',
            defaultValue: false,
            description: 'Remove services that no longer exist in the repository'
        )
    }

    stages {
        stage('Discover VMs') {
            agent any
            steps {
                checkout scm
                script {
                    env.GIT_COMMIT_SHORT = sh(
                        script: 'git rev-parse --short HEAD',
                        returnStdout: true
                    ).trim()
                    echo "Building commit: ${env.GIT_COMMIT_SHORT}"
                    echo "Deploy mode: ${params.DEPLOY_MODE}"

                    // Find all IP directories (pattern: X.X.X.X)
                    def vmDirsRaw = sh(
                        script: '''
                            find . -maxdepth 1 -type d -regex '.*/[0-9]+\\.[0-9]+\\.[0-9]+\\.[0-9]+' | \
                            sed 's|^./||' | \
                            sort
                        ''',
                        returnStdout: true
                    ).trim()

                    if (vmDirsRaw.isEmpty()) {
                        error "No VM directories found! Expected directories named like IP addresses (e.g. 192.168.2.31/)"
                    }

                    // Store for next stages (simple string, no serialization issues)
                    env.VM_DIRS = vmDirsRaw

                    echo "\n=========================================="
                    echo "DISCOVERED VMs"
                    echo "==========================================\n"
                    
                    vmDirsRaw.split('\n').each { vmIp ->
                        echo "ğŸ“ ${vmIp}"
                    }
                }
            }
        }

        stage('Deploy to VMs') {
            steps {
                script {
                    def vmDirs = env.VM_DIRS.split('\n')
                    def deployOnlyVm = params.DEPLOY_ONLY_VM?.trim()
                    def deployOnlyService = params.DEPLOY_ONLY_SERVICE?.trim()
                    def deployMode = params.DEPLOY_MODE
                    def prune = params.PRUNE

                    // Filter VMs if specified
                    if (deployOnlyVm) {
                        vmDirs = vmDirs.findAll { it == deployOnlyVm }
                        if (vmDirs.size() == 0) {
                            error "VM ${deployOnlyVm} not found!"
                        }
                    }

                    // Track results
                    def allResults = [:]
                    def removedServices = []

                    // Deploy to each VM using its agent
                    vmDirs.each { vmIp ->
                        stage("Deploy to ${vmIp}") {
                            node(vmIp) {
                                def vmDeploymentPath = "${env.DEPLOYMENT_BASE}/${vmIp}"
                                
                                // For DEPLOY and CLEAN_DEPLOY modes, we need the git checkout
                                if (deployMode in ['DEPLOY', 'CLEAN_DEPLOY']) {
                                    // Clean workspace from root-owned files/directories
                                    sh '''
                                        find . -mindepth 1 -user root -delete 2>/dev/null || true
                                        find . -mindepth 1 -type d -empty -delete 2>/dev/null || true
                                    '''
                                    
                                    checkout scm
                                }

                                // Get list of services based on mode
                                def repoServices = []
                                
                                if (deployMode in ['DEPLOY', 'CLEAN_DEPLOY']) {
                                    // Find services from git checkout
                                    def servicesRaw = sh(
                                        script: """
                                            find ./${vmIp} -maxdepth 2 -type f \\( -name "docker-compose.yaml" -o -name "docker-compose.yml" \\) | \
                                            sed 's|^\\./||' | \
                                            sed 's|^${vmIp}/||' | \
                                            sed 's|/docker-compose.ya\\?ml\$||' | \
                                            sort
                                        """,
                                        returnStdout: true
                                    ).trim()
                                    repoServices = servicesRaw ? servicesRaw.split('\n').toList() : []
                                } else {
                                    // For START_MISSING and RESTART_ALL, find services from deployment directory
                                    def servicesRaw = sh(
                                        script: """
                                            if [ -d "${vmDeploymentPath}" ]; then
                                                find ${vmDeploymentPath} -maxdepth 2 -type f \\( -name "docker-compose.yaml" -o -name "docker-compose.yml" \\) | \
                                                sed 's|${vmDeploymentPath}/||' | \
                                                sed 's|/docker-compose.ya\\?ml\$||' | \
                                                sort
                                            fi
                                        """,
                                        returnStdout: true
                                    ).trim()
                                    repoServices = servicesRaw ? servicesRaw.split('\n').toList() : []
                                }

                                echo "\n=========================================="
                                echo "VM: ${vmIp} | Mode: ${deployMode}"
                                echo "==========================================\n"
                                echo "ğŸ“¦ Services found: ${repoServices.join(', ') ?: 'none'}"

                                // Prune: Find and remove services no longer in repo
                                if (prune && !deployOnlyService && deployMode in ['DEPLOY', 'CLEAN_DEPLOY']) {
                                    def runningRaw = sh(
                                        script: """
                                            docker compose ls --format json 2>/dev/null | \
                                            jq -r '.[].Name' 2>/dev/null | \
                                            grep '^${env.COMPOSE_PROJECT_PREFIX}-' | \
                                            sed 's|^${env.COMPOSE_PROJECT_PREFIX}-||' | \
                                            sort || true
                                        """,
                                        returnStdout: true
                                    ).trim()

                                    def runningServices = runningRaw ? runningRaw.split('\n').toList() : []
                                    def toRemove = runningServices.findAll { !repoServices.contains(it) }

                                    if (toRemove.size() > 0) {
                                        echo "\nğŸ—‘ï¸ Pruning removed services: ${toRemove.join(', ')}"
                                        toRemove.each { serviceName ->
                                            def projectName = "${env.COMPOSE_PROJECT_PREFIX}-${serviceName}"
                                            try {
                                                sh "docker compose -p ${projectName} down --remove-orphans --volumes || true"
                                                echo "âœ… ${serviceName} removed"
                                                removedServices.add("${vmIp}/${serviceName}")
                                            } catch (Exception e) {
                                                echo "âš ï¸ Failed to remove ${serviceName}: ${e.message}"
                                            }
                                        }
                                    }
                                }

                                // Filter services if specified
                                def servicesToDeploy = repoServices
                                if (deployOnlyService) {
                                    def allowedServices = deployOnlyService.split(',').collect { it.trim() }
                                    servicesToDeploy = repoServices.findAll { service ->
                                        allowedServices.any { allowed -> service.contains(allowed) }
                                    }
                                    if (servicesToDeploy.isEmpty()) {
                                        echo "âš ï¸ No matching services found for filter: ${deployOnlyService}"
                                        return
                                    }
                                }

                                if (servicesToDeploy.isEmpty()) {
                                    echo "âš ï¸ No services to deploy"
                                    return
                                }

                                echo "\nğŸš€ Processing: ${servicesToDeploy.join(', ')}"

                                // Process each service
                                servicesToDeploy.each { serviceName ->
                                    def servicePath = "${vmDeploymentPath}/${serviceName}"
                                    def projectName = "${env.COMPOSE_PROJECT_PREFIX}-${serviceName}"

                                    echo "\n--- ${serviceName} ---"

                                    try {
                                        // Handle file operations based on mode
                                        if (deployMode == 'CLEAN_DEPLOY') {
                                            // Delete everything including persistence
                                            echo "ğŸ§¹ Clean deploy: Removing all data including persistence/"
                                            sh """
                                                rm -rf ${servicePath} 2>/dev/null || true
                                                mkdir -p ${servicePath}
                                                cd ./${vmIp}/${serviceName} && tar --exclude='*@tmp' -cf - . | (cd ${servicePath} && tar -xf -)
                                            """
                                        } else if (deployMode == 'DEPLOY') {
                                            // Copy files - tar overwrites but doesn't delete, so persistence/ stays
                                            echo "ğŸ“¦ Deploy: Updating configs (persistence/ stays untouched)"
                                            sh """
                                                mkdir -p ${servicePath}
                                                cd ./${vmIp}/${serviceName} && tar --exclude='*@tmp' -cf - . | (cd ${servicePath} && tar -xf -)
                                            """
                                        }
                                        // For START_MISSING and RESTART_ALL, no file operations

                                        // Docker operations
                                        dir(servicePath) {
                                            // Copy .env file if present
                                            if (fileExists(".env.example") && !fileExists(".env")) {
                                                sh "cp .env.example .env"
                                                echo "ğŸ“‹ Copied .env.example to .env"
                                            }

                                            def composeCmd = "docker compose -p ${projectName}"
                                            
                                            // Validate compose file
                                            def validateResult = sh(
                                                script: "${composeCmd} config --quiet",
                                                returnStatus: true
                                            )
                                            
                                            if (validateResult != 0) {
                                                echo "âŒ ${serviceName}: Invalid compose file"
                                                allResults["${vmIp}/${serviceName}"] = 'FAILED'
                                                return
                                            }

                                            if (deployMode == 'START_MISSING') {
                                                // Only start if not running
                                                def isRunning = sh(
                                                    script: "${composeCmd} ps -q 2>/dev/null | head -1",
                                                    returnStdout: true
                                                ).trim()
                                                
                                                if (isRunning) {
                                                    echo "â­ï¸ ${serviceName} already running, skipping"
                                                    allResults["${vmIp}/${serviceName}"] = 'SKIPPED'
                                                    return
                                                }
                                                
                                                echo "â–¶ï¸ Starting ${serviceName}..."
                                                sh "${composeCmd} up -d"
                                                
                                            } else if (deployMode == 'RESTART_ALL') {
                                                // Restart all containers
                                                echo "ğŸ”„ Restarting ${serviceName}..."
                                                sh "${composeCmd} restart || ${composeCmd} up -d"
                                                
                                            } else {
                                                // DEPLOY or CLEAN_DEPLOY - full deployment
                                                echo "ğŸš€ Deploying ${serviceName}..."
                                                sh "${composeCmd} pull --ignore-pull-failures || true"
                                                sh "${composeCmd} down --remove-orphans || true"
                                                sh "${composeCmd} up -d --pull always --remove-orphans"
                                            }

                                            // Show status
                                            sh "${composeCmd} ps"
                                        }

                                        echo "âœ… ${serviceName} completed"
                                        allResults["${vmIp}/${serviceName}"] = 'SUCCESS'

                                    } catch (Exception e) {
                                        echo "âŒ ${serviceName} failed: ${e.message}"
                                        allResults["${vmIp}/${serviceName}"] = 'FAILED'
                                        currentBuild.result = 'UNSTABLE'
                                    }
                                }

                                // Cleanup @tmp directories created by Jenkins dir() step
                                sh """
                                    find ${vmDeploymentPath} -maxdepth 1 -type d -name '*@tmp' -exec rm -rf {} + 2>/dev/null || true
                                """

                                // Cleanup unused Docker resources
                                if (deployMode in ['DEPLOY', 'CLEAN_DEPLOY']) {
                                    echo "\nCleaning up unused Docker resources..."
                                    sh '''
                                        docker image prune -f --filter "until=168h" || true
                                        docker network prune -f || true
                                    '''
                                }
                            }
                        }
                    }

                    // Final Summary
                    echo "\n=========================================="
                    echo "DEPLOYMENT SUMMARY (Mode: ${deployMode})"
                    echo "==========================================\n"
                    
                    def successful = allResults.findAll { it.value == 'SUCCESS' }
                    def skipped = allResults.findAll { it.value == 'SKIPPED' }
                    def failed = allResults.findAll { it.value == 'FAILED' }

                    if (successful.size() > 0) {
                        echo "âœ… Success (${successful.size()}):"
                        successful.each { key, value -> echo "   - ${key}" }
                    }

                    if (skipped.size() > 0) {
                        echo "\nâ­ï¸ Skipped (${skipped.size()}):"
                        skipped.each { key, value -> echo "   - ${key}" }
                    }

                    if (removedServices.size() > 0) {
                        echo "\nğŸ—‘ï¸ Pruned (${removedServices.size()}):"
                        removedServices.each { echo "   - ${it}" }
                    }
                    
                    if (failed.size() > 0) {
                        echo "\nâŒ Failed (${failed.size()}):"
                        failed.each { key, value -> echo "   - ${key}" }
                        unstable("Some services failed")
                    }
                }
            }
        }
    }

    post {
        success {
            echo "ğŸ‰ Homelab deployment completed successfully!"
        }
        unstable {
            echo "âš ï¸ Homelab deployment completed with warnings"
        }
        failure {
            echo "ğŸ’¥ Homelab deployment failed!"
        }
    }
}
